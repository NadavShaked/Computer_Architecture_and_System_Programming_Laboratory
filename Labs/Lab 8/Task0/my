#include <stdlib.h>
#include <stdio.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#include "elf.h"

typedef struct {
  char debug_mode;
//   char file_name[128];
//   int unit_size;
//   unsigned char mem_buf[10000];
//   size_t mem_count;
//   int hexadecimal_mode;
} state;

struct fun_desc {
    char* name;
    void (*fun)(state*);
};

void toggleDebugMode(state* s){
  if(s->debug_mode == 1){
    s->debug_mode = 0;
        printf("Debug flag now off \n");
  }
  else {
    s->debug_mode = 1;
    printf("Debug flag now on \n");
  }
}

void tttt() {
    char input[200];
    fgets(input, 200, stdin);
    if (input[strsize(input) - 1] == '\n')
        input[strsize(input) - 1] == 0;

    int fd;
    void *map_start; /* will point to the start of the memory mapped file */
    struct stat fd_stat; /* this is needed to  the size of the file */
    Elf32_Ehdr *header; /* this will point to the header structure */
    int num_of_section_headers;

    if( (fd = open(input, O_RDWR)) < 0 ) {
        perror("error in open");
        exit(-1);
    }

    if( fstat(fd, &fd_stat) != 0 ) {
        perror("stat failed");
        exit(-1);
    }

    if ( (map_start = mmap(0, fd_stat.st_size, PROT_READ | PROT_WRITE , MAP_SHARED, fd, 0)) == MAP_FAILED ) {
        perror("mmap failed");
        exit(-4);
    }

    /* now, the file is mapped starting at map_start.
    * all we need to do is tell *header to point at the same address:
    */

    header = (Elf32_Ehdr *) map_start;
    /* now we can do whatever we want with header!!!!
    * for example, the number of section header can be obtained like this:
    */

/*
Bytes 1,2,3 of the magic number (in ASCII). Henceforth, you should check that the number is consistent with an ELF file, and refuse to continue if it is not.
The data encoding scheme of the object file.
Entry point (hexadecimal address).
The file offset in which the section header table resides.
The number of section header entries.
The size of each section header entry.
The file offset in which the program header table resides.
The number of program header entries.
The size of each program header entry.
*/
    printf("%c", header->e_ident[1]);   //print the magic number 1
    printf("%c", header->e_ident[2]);   //print the magic number 2
    printf("%c", header->e_ident[3]);   //print the magic number 3
    printf("%X", header->e_entry);      //print the entry point
    printf("%X", header->e_shoff);      //print the file offset
    int num_of_headers = header->e_shnum;
    printf("%d", num_of_headers);      //print the number of headers
    for (int i = 0; i < num_of_headers; i++) {

    }
    /* now, we unmap the file */
    munmap(map_start, fd_stat.st_size);
}

initializeState(state* s) {
    s->debug_mode = 0;
}

int main(int argc, char **argv){
    int base_len = 5;
    char userInput[11];

    struct fun_desc menu[]= { { "Toggle Debug Mode", toggleDebugMode }, { NULL, NULL } };
    int menuLen = (sizeof(menu) / sizeof(menu[0])) - 1;
    state s;
    initializeState(&s);
    printf("menu\n");
    while (1) {
        if(s.debug_mode == 1)
            printStateStatus(&s);
        printf("Please choose a function:\n");
        for (int i = 0; i < menuLen; i++) {
            printf("%d) %s\n", i, menu[i].name);
        }
        printf("Option: ");
        fgets(userInput, 10, stdin);
        int i = atoi(userInput);

        if (i >= 0 && i < menuLen)
            menu[i].fun(&s);
        else {
            printf("Not within bounds\n");
            quit(&s);
        }
    }
}